From 2581a21c5481a37e2f96f678768db04a49f083a2 Mon Sep 17 00:00:00 2001
From: pseregiet <patryk.seregiet@gmail.com>
Date: Sun, 16 Jan 2022 21:55:31 +0100
Subject: [PATCH 2/2] Experimental depth read support, D3D11 and WebGL 2

by peter.hillerstrom@hiberworld.com
rebased for new sokol
---
 0001-sg_make_image_with_mipmaps.patch         | 127 ++++++++++
 ...th-read-support-D3D11-and-WebGL-2-sh.patch | 224 ++++++++++++++++++
 sokol_gfx.h                                   | 125 ++++++----
 3 files changed, 433 insertions(+), 43 deletions(-)
 create mode 100644 0001-sg_make_image_with_mipmaps.patch
 create mode 100644 0002-Experimental-depth-read-support-D3D11-and-WebGL-2-sh.patch

diff --git a/0001-sg_make_image_with_mipmaps.patch b/0001-sg_make_image_with_mipmaps.patch
new file mode 100644
index 0000000..556631d
--- /dev/null
+++ b/0001-sg_make_image_with_mipmaps.patch
@@ -0,0 +1,127 @@
+From c80250e0f7d83367afbbb57446f35565cef3c018 Mon Sep 17 00:00:00 2001
+From: pseregiet <patryk.seregiet@gmail.com>
+Date: Fri, 31 Dec 2021 00:43:31 +0100
+Subject: [PATCH 1/2] sg_make_image_with_mipmaps
+
+---
+ sokol_gfx.h | 97 +++++++++++++++++++++++++++++++++++++++++++++++++++++
+ 1 file changed, 97 insertions(+)
+
+diff --git a/sokol_gfx.h b/sokol_gfx.h
+index e084e24..72c5d62 100644
+--- a/sokol_gfx.h
++++ b/sokol_gfx.h
+@@ -2277,6 +2277,7 @@ SOKOL_GFX_API_DECL void sg_pop_debug_group(void);
+ /* resource creation, destruction and updating */
+ SOKOL_GFX_API_DECL sg_buffer sg_make_buffer(const sg_buffer_desc* desc);
+ SOKOL_GFX_API_DECL sg_image sg_make_image(const sg_image_desc* desc);
++SOKOL_GFX_API_DECL sg_image sg_make_image_with_mipmaps(const sg_image_desc* desc);
+ SOKOL_GFX_API_DECL sg_shader sg_make_shader(const sg_shader_desc* desc);
+ SOKOL_GFX_API_DECL sg_pipeline sg_make_pipeline(const sg_pipeline_desc* desc);
+ SOKOL_GFX_API_DECL sg_pass sg_make_pass(const sg_pass_desc* desc);
+@@ -15164,6 +15165,102 @@ SOKOL_API_IMPL sg_image sg_make_image(const sg_image_desc* desc) {
+     return img_id;
+ }
+ 
++SOKOL_API_IMPL sg_image sg_make_image_with_mipmaps(const sg_image_desc* desc_)
++{
++    sg_image_desc desc = *desc_;
++    SOKOL_ASSERT(desc.pixel_format == SG_PIXELFORMAT_RGBA8
++                || desc.pixel_format == SG_PIXELFORMAT_BGRA8
++                || desc.pixel_format == SG_PIXELFORMAT_R8);
++
++    unsigned pixel_size = _sg_pixelformat_bytesize(desc.pixel_format);
++    int w = desc.width;
++    int h = desc.height * desc.num_slices;
++    int total_size = 0;
++    for (int level = 1; level < SG_MAX_MIPMAPS; ++level) {
++        w /=2;
++        h /=2;
++
++        if (w < 1 && h < 1)
++            break;
++
++        total_size += (w * h * pixel_size);
++    }
++
++    int cube_faces = 0;
++    for (; cube_faces < SG_CUBEFACE_NUM; ++cube_faces) {
++        if (!desc.data.subimage[cube_faces][0].ptr)
++            break;
++    }
++
++    total_size *= (cube_faces+1);
++    unsigned char *big_target = SOKOL_MALLOC(total_size);
++    unsigned char *target = big_target;
++
++    for (int cube_face = 0; cube_face < cube_faces; ++cube_face)
++    {
++        int target_width = desc.width;
++        int target_height = desc.height;
++        int dst_height = target_height * desc.num_slices;
++
++        for (int level = 1; level < SG_MAX_MIPMAPS; ++level) {
++            unsigned char* source = (unsigned char*)desc.data.subimage[cube_face][level - 1].ptr;
++            if (!source)
++                break;
++
++            int source_width = target_width;
++            int source_height = target_height;
++            target_width /= 2;
++            target_height /= 2;
++            if (target_width < 1 && target_height < 1)
++                break;
++
++            if (target_width < 1)
++                target_width = 1;
++
++            if (target_height < 1)
++                target_height = 1;
++
++            dst_height /= 2;
++            unsigned img_size = target_width * dst_height * pixel_size;
++            unsigned char *miptarget = target;
++
++            for (int slice = 0; slice < desc.num_slices; ++slice) {
++                for (int x = 0; x < target_width; ++x)
++                {
++                    for (int y = 0; y < target_height; ++y)
++                    {
++                        uint16_t colors[8] = { 0 };
++                        for (int chanell = 0; chanell < pixel_size; ++chanell)
++                        {
++                            int color = 0;
++                            int sx = x * 2;
++                            int sy = y * 2;
++                            color += source[source_width * pixel_size * sx + sy * pixel_size + chanell];
++                            color += source[source_width * pixel_size * (sx + 1) + sy * pixel_size + chanell];
++                            color += source[source_width * pixel_size * (sx + 1) + (sy + 1) * pixel_size + chanell];
++                            color += source[source_width * pixel_size * sx + (sy + 1) * pixel_size + chanell];
++                            color /= 4;
++                            miptarget[target_width * pixel_size * (x) + (y) * pixel_size + chanell] = (uint8_t)color;
++                        }
++                    }
++                }
++
++                source += (source_width * source_height * pixel_size);
++                miptarget += (target_width * target_height * pixel_size);
++            }
++            desc.data.subimage[cube_face][level].ptr = target;
++            desc.data.subimage[cube_face][level].size = img_size;
++            target += img_size;
++            if (desc.num_mipmaps <= level)
++                desc.num_mipmaps = level + 1;
++        }
++    }
++
++    sg_image img = sg_make_image(&desc);
++    SOKOL_FREE(big_target);
++    return img;
++}
++
+ SOKOL_API_IMPL sg_shader sg_make_shader(const sg_shader_desc* desc) {
+     SOKOL_ASSERT(_sg.valid);
+     SOKOL_ASSERT(desc);
+-- 
+2.34.1
+
diff --git a/0002-Experimental-depth-read-support-D3D11-and-WebGL-2-sh.patch b/0002-Experimental-depth-read-support-D3D11-and-WebGL-2-sh.patch
new file mode 100644
index 0000000..6281e32
--- /dev/null
+++ b/0002-Experimental-depth-read-support-D3D11-and-WebGL-2-sh.patch
@@ -0,0 +1,224 @@
+From 49c4a8fbac10ed6e8ec3b935cc95fbc28ee73b40 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Peter=20Hillerstr=C3=B6m?=
+ <peter.hillerstrom@hiberworld.com>
+Date: Thu, 9 Dec 2021 15:15:41 +0100
+Subject: [PATCH 2/2] Experimental depth read support, D3D11 and WebGL 2 should
+ work.
+
+---
+ sokol_gfx.h | 122 +++++++++++++++++++++++++++++++++++-----------------
+ 1 file changed, 82 insertions(+), 40 deletions(-)
+
+diff --git a/sokol_gfx.h b/sokol_gfx.h
+index 72c5d62..3cfc497 100644
+--- a/sokol_gfx.h
++++ b/sokol_gfx.h
+@@ -3475,6 +3475,7 @@ typedef struct {
+     _sg_gl_state_cache_t cache;
+     bool ext_anisotropic;
+     GLint max_anisotropy;
++    bool ext_depth_read;
+     GLint max_combined_texture_image_units;
+     #if _SOKOL_USE_WIN32_GL_LOADER
+     HINSTANCE opengl32_dll;
+@@ -5564,6 +5565,7 @@ _SOKOL_PRIVATE void _sg_gl_init_caps_glcore33(void) {
+     _sg.features.image_clamp_to_border = true;
+     _sg.features.mrt_independent_blend_state = false;
+     _sg.features.mrt_independent_write_mask = true;
++    _sg.gl.ext_depth_read = true;
+ 
+     /* scan extensions */
+     bool has_s3tc = false;  /* BC1..BC3 */
+@@ -5641,6 +5643,7 @@ _SOKOL_PRIVATE void _sg_gl_init_caps_gles3(void) {
+     _sg.features.image_clamp_to_border = false;
+     _sg.features.mrt_independent_blend_state = false;
+     _sg.features.mrt_independent_write_mask = false;
++    _sg.gl.ext_depth_read = true;
+ 
+     bool has_s3tc = false;  /* BC1..BC3 */
+     bool has_rgtc = false;  /* BC4 and BC5 */
+@@ -5765,6 +5768,7 @@ _SOKOL_PRIVATE void _sg_gl_init_caps_gles2(void) {
+         */
+         has_instancing = strstr(ext, "_instanced_arrays");
+         _sg.gl.ext_anisotropic = strstr(ext, "ext_anisotropic");
++        _sg.gl.ext_depth_read = strstr(ext, "_depth_texture");
+     }
+ 
+     _sg.features.origin_top_left = false;
+@@ -6234,7 +6238,7 @@ _SOKOL_PRIVATE sg_resource_state _sg_gl_create_image(_sg_image_t* img, const sg_
+     }
+     #endif
+ 
+-    if (_sg_is_valid_rendertarget_depth_format(img->cmn.pixel_format)) {
++    if (!_sg.gl.ext_depth_read && _sg_is_valid_rendertarget_depth_format(img->cmn.pixel_format)) {
+         /* special case depth-stencil-buffer? */
+         SOKOL_ASSERT((img->cmn.usage == SG_USAGE_IMMUTABLE) && (img->cmn.num_slots == 1));
+         SOKOL_ASSERT(!img->gl.ext_textures);   /* cannot provide external texture for depth images */
+@@ -6706,11 +6710,21 @@ _SOKOL_PRIVATE sg_resource_state _sg_gl_create_pass(_sg_pass_t* pass, _sg_image_
+ 
+     /* attach depth-stencil buffer to framebuffer */
+     if (pass->gl.ds_att.image) {
+-        const GLuint gl_render_buffer = pass->gl.ds_att.image->gl.depth_render_buffer;
+-        SOKOL_ASSERT(gl_render_buffer);
+-        glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, gl_render_buffer);
+-        if (_sg_is_depth_stencil_format(pass->gl.ds_att.image->cmn.pixel_format)) {
+-            glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_STENCIL_ATTACHMENT, GL_RENDERBUFFER, gl_render_buffer);
++        if (_sg.gl.ext_depth_read) {
++            const GLuint gl_depth_tex = pass->gl.ds_att.image->gl.tex[0];
++            SOKOL_ASSERT(gl_depth_tex);
++            glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_TEXTURE_2D, gl_depth_tex, 0);
++             if (_sg_is_depth_stencil_format(pass->gl.ds_att.image->cmn.pixel_format)) {
++                glFramebufferTexture2D(GL_FRAMEBUFFER, GL_STENCIL_ATTACHMENT, GL_TEXTURE_2D, gl_depth_tex, 0);
++            }
++        }
++        else {
++            const GLuint gl_render_buffer = pass->gl.ds_att.image->gl.depth_render_buffer;
++            SOKOL_ASSERT(gl_render_buffer);
++            glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, gl_render_buffer);
++            if (_sg_is_depth_stencil_format(pass->gl.ds_att.image->cmn.pixel_format)) {
++                glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_STENCIL_ATTACHMENT, GL_RENDERBUFFER, gl_render_buffer);
++            }
+         }
+     }
+ 
+@@ -8319,19 +8333,39 @@ _SOKOL_PRIVATE sg_resource_state _sg_d3d11_create_image(_sg_image_t* img, const
+             SOKOL_LOG("trying to create a D3D11 depth-texture with unsupported pixel format\n");
+             return SG_RESOURCESTATE_FAILED;
+         }
++        /* need special typeless formats, only support known depth formats */
++        SOKOL_ASSERT(img->cmn.pixel_format == SG_PIXELFORMAT_DEPTH || img->cmn.pixel_format == SG_PIXELFORMAT_DEPTH_STENCIL);
++        DXGI_FORMAT res_format = {};
++        DXGI_FORMAT srv_format = {};
++        if (img->cmn.pixel_format == SG_PIXELFORMAT_DEPTH) {
++            res_format = DXGI_FORMAT_R32_TYPELESS;
++            srv_format = DXGI_FORMAT_R32_FLOAT;
++        }
++        else if (img->cmn.pixel_format == SG_PIXELFORMAT_DEPTH_STENCIL) {
++            res_format = DXGI_FORMAT_R24G8_TYPELESS;
++            srv_format = DXGI_FORMAT_R24_UNORM_X8_TYPELESS;
++        }
+         D3D11_TEXTURE2D_DESC d3d11_desc;
+         memset(&d3d11_desc, 0, sizeof(d3d11_desc));
+         d3d11_desc.Width = (UINT)img->cmn.width;
+         d3d11_desc.Height = (UINT)img->cmn.height;
+         d3d11_desc.MipLevels = 1;
+         d3d11_desc.ArraySize = 1;
+-        d3d11_desc.Format = img->d3d11.format;
++        d3d11_desc.Format = res_format;
+         d3d11_desc.Usage = D3D11_USAGE_DEFAULT;
+-        d3d11_desc.BindFlags = D3D11_BIND_DEPTH_STENCIL;
++        d3d11_desc.BindFlags = D3D11_BIND_DEPTH_STENCIL | D3D11_BIND_SHADER_RESOURCE;
+         d3d11_desc.SampleDesc.Count = (UINT)img->cmn.sample_count;
+         d3d11_desc.SampleDesc.Quality = (UINT) (msaa ? D3D11_STANDARD_MULTISAMPLE_PATTERN : 0);
+         hr = _sg_d3d11_CreateTexture2D(_sg.d3d11.dev, &d3d11_desc, NULL, &img->d3d11.texds);
+         SOKOL_ASSERT(SUCCEEDED(hr) && img->d3d11.texds);
++
++        D3D11_SHADER_RESOURCE_VIEW_DESC d3d11_srv_desc;
++        memset(&d3d11_srv_desc, 0, sizeof(d3d11_srv_desc));
++        d3d11_srv_desc.Format = srv_format;
++        d3d11_srv_desc.ViewDimension = D3D11_SRV_DIMENSION_TEXTURE2D;
++        d3d11_srv_desc.Texture2D.MipLevels = 1;
++        hr = _sg_d3d11_CreateShaderResourceView(_sg.d3d11.dev, (ID3D11Resource*)img->d3d11.texds, &d3d11_srv_desc, &img->d3d11.srv);
++        SOKOL_ASSERT(SUCCEEDED(hr) && img->d3d11.srv);
+     }
+     else {
+         /* create (or inject) color texture and shader-resource-view */
+@@ -8505,35 +8539,36 @@ _SOKOL_PRIVATE sg_resource_state _sg_d3d11_create_image(_sg_image_t* img, const
+             hr = _sg_d3d11_CreateTexture2D(_sg.d3d11.dev, &d3d11_tex_desc, NULL, &img->d3d11.texmsaa);
+             SOKOL_ASSERT(SUCCEEDED(hr) && img->d3d11.texmsaa);
+         }
++    }
+ 
+-        /* sampler state object, note D3D11 implements an internal shared-pool for sampler objects */
+-        D3D11_SAMPLER_DESC d3d11_smp_desc;
+-        memset(&d3d11_smp_desc, 0, sizeof(d3d11_smp_desc));
+-        d3d11_smp_desc.Filter = _sg_d3d11_filter(img->cmn.min_filter, img->cmn.mag_filter, img->cmn.max_anisotropy);
+-        d3d11_smp_desc.AddressU = _sg_d3d11_address_mode(img->cmn.wrap_u);
+-        d3d11_smp_desc.AddressV = _sg_d3d11_address_mode(img->cmn.wrap_v);
+-        d3d11_smp_desc.AddressW = _sg_d3d11_address_mode(img->cmn.wrap_w);
+-        switch (img->cmn.border_color) {
+-            case SG_BORDERCOLOR_TRANSPARENT_BLACK:
+-                /* all 0.0f */
+-                break;
+-            case SG_BORDERCOLOR_OPAQUE_WHITE:
+-                for (int i = 0; i < 4; i++) {
+-                    d3d11_smp_desc.BorderColor[i] = 1.0f;
+-                }
+-                break;
+-            default:
+-                /* opaque black */
+-                d3d11_smp_desc.BorderColor[3] = 1.0f;
+-                break;
+-        }
+-        d3d11_smp_desc.MaxAnisotropy = img->cmn.max_anisotropy;
+-        d3d11_smp_desc.ComparisonFunc = D3D11_COMPARISON_NEVER;
+-        d3d11_smp_desc.MinLOD = desc->min_lod;
+-        d3d11_smp_desc.MaxLOD = desc->max_lod;
+-        hr = _sg_d3d11_CreateSamplerState(_sg.d3d11.dev, &d3d11_smp_desc, &img->d3d11.smp);
+-        SOKOL_ASSERT(SUCCEEDED(hr) && img->d3d11.smp);
++    /* sampler state object, note D3D11 implements an internal shared-pool for sampler objects */
++    D3D11_SAMPLER_DESC d3d11_smp_desc;
++    memset(&d3d11_smp_desc, 0, sizeof(d3d11_smp_desc));
++    d3d11_smp_desc.Filter = _sg_d3d11_filter(img->cmn.min_filter, img->cmn.mag_filter, img->cmn.max_anisotropy);
++    d3d11_smp_desc.AddressU = _sg_d3d11_address_mode(img->cmn.wrap_u);
++    d3d11_smp_desc.AddressV = _sg_d3d11_address_mode(img->cmn.wrap_v);
++    d3d11_smp_desc.AddressW = _sg_d3d11_address_mode(img->cmn.wrap_w);
++    switch (img->cmn.border_color) {
++        case SG_BORDERCOLOR_TRANSPARENT_BLACK:
++            /* all 0.0f */
++            break;
++        case SG_BORDERCOLOR_OPAQUE_WHITE:
++            for (int i = 0; i < 4; i++) {
++                d3d11_smp_desc.BorderColor[i] = 1.0f;
++            }
++            break;
++        default:
++            /* opaque black */
++            d3d11_smp_desc.BorderColor[3] = 1.0f;
++            break;
+     }
++    d3d11_smp_desc.MaxAnisotropy = img->cmn.max_anisotropy;
++    d3d11_smp_desc.ComparisonFunc = D3D11_COMPARISON_NEVER;
++    d3d11_smp_desc.MinLOD = desc->min_lod;
++    d3d11_smp_desc.MaxLOD = desc->max_lod;
++    hr = _sg_d3d11_CreateSamplerState(_sg.d3d11.dev, &d3d11_smp_desc, &img->d3d11.smp);
++    SOKOL_ASSERT(SUCCEEDED(hr) && img->d3d11.smp);
++
+     return SG_RESOURCESTATE_VALID;
+ }
+ 
+@@ -10314,10 +10349,11 @@ _SOKOL_PRIVATE sg_resource_state _sg_mtl_create_image(_sg_image_t* img, const sg
+             id<MTLTexture> tex = [_sg.mtl.device newTextureWithDescriptor:mtl_desc];
+             img->mtl.msaa_tex = _sg_mtl_add_resource(tex);
+         }
+-
+-        /* create (possibly shared) sampler state */
+-        img->mtl.sampler_state = _sg_mtl_create_sampler(_sg.mtl.device, desc);
+     }
++
++    /* create (possibly shared) sampler state */
++    img->mtl.sampler_state = _sg_mtl_create_sampler(_sg.mtl.device, desc);
++
+     _SG_OBJC_RELEASE(mtl_desc);
+     return SG_RESOURCESTATE_VALID;
+ }
+@@ -10898,8 +10934,14 @@ _SOKOL_PRIVATE void _sg_mtl_apply_bindings(
+         if ((_sg.mtl.state_cache.cur_fs_images[slot] != img) || (_sg.mtl.state_cache.cur_fs_image_ids[slot].id != img->slot.id)) {
+             _sg.mtl.state_cache.cur_fs_images[slot] = img;
+             _sg.mtl.state_cache.cur_fs_image_ids[slot].id = img->slot.id;
+-            SOKOL_ASSERT(img->mtl.tex[img->cmn.active_slot] != _SG_MTL_INVALID_SLOT_INDEX);
+-            [_sg.mtl.cmd_encoder setFragmentTexture:_sg_mtl_id(img->mtl.tex[img->cmn.active_slot]) atIndex:slot];
++            SOKOL_ASSERT(img->mtl.tex[img->cmn.active_slot] != _SG_MTL_INVALID_SLOT_INDEX ||
++                img->mtl.depth_tex != _SG_MTL_INVALID_SLOT_INDEX);
++            if (img->mtl.depth_tex) {
++                [_sg.mtl.cmd_encoder setFragmentTexture:_sg_mtl_id(img->mtl.depth_tex) atIndex:slot];
++            }
++            else {
++                [_sg.mtl.cmd_encoder setFragmentTexture:_sg_mtl_id(img->mtl.tex[img->cmn.active_slot]) atIndex:slot];
++            }
+             SOKOL_ASSERT(img->mtl.sampler_state != _SG_MTL_INVALID_SLOT_INDEX);
+             [_sg.mtl.cmd_encoder setFragmentSamplerState:_sg_mtl_id(img->mtl.sampler_state) atIndex:slot];
+         }
+-- 
+2.34.1
+
diff --git a/sokol_gfx.h b/sokol_gfx.h
index edf88b1..eac229a 100644
--- a/sokol_gfx.h
+++ b/sokol_gfx.h
@@ -3627,6 +3627,7 @@ typedef struct {
     _sg_gl_state_cache_t cache;
     bool ext_anisotropic;
     GLint max_anisotropy;
+    bool ext_depth_read;
     GLint max_combined_texture_image_units;
     #if _SOKOL_USE_WIN32_GL_LOADER
     HINSTANCE opengl32_dll;
@@ -5811,6 +5812,7 @@ _SOKOL_PRIVATE void _sg_gl_init_caps_glcore33(void) {
     _sg.features.image_clamp_to_border = true;
     _sg.features.mrt_independent_blend_state = false;
     _sg.features.mrt_independent_write_mask = true;
+    _sg.gl.ext_depth_read = true;
 
     /* scan extensions */
     bool has_s3tc = false;  /* BC1..BC3 */
@@ -5888,6 +5890,7 @@ _SOKOL_PRIVATE void _sg_gl_init_caps_gles3(void) {
     _sg.features.image_clamp_to_border = false;
     _sg.features.mrt_independent_blend_state = false;
     _sg.features.mrt_independent_write_mask = false;
+    _sg.gl.ext_depth_read = true;
 
     bool has_s3tc = false;  /* BC1..BC3 */
     bool has_rgtc = false;  /* BC4 and BC5 */
@@ -6012,6 +6015,7 @@ _SOKOL_PRIVATE void _sg_gl_init_caps_gles2(void) {
         */
         has_instancing = strstr(ext, "_instanced_arrays");
         _sg.gl.ext_anisotropic = strstr(ext, "ext_anisotropic");
+        _sg.gl.ext_depth_read = strstr(ext, "_depth_texture");
     }
 
     _sg.features.origin_top_left = false;
@@ -6481,7 +6485,7 @@ _SOKOL_PRIVATE sg_resource_state _sg_gl_create_image(_sg_image_t* img, const sg_
     }
     #endif
 
-    if (_sg_is_valid_rendertarget_depth_format(img->cmn.pixel_format)) {
+    if (!_sg.gl.ext_depth_read && _sg_is_valid_rendertarget_depth_format(img->cmn.pixel_format)) {
         /* special case depth-stencil-buffer? */
         SOKOL_ASSERT((img->cmn.usage == SG_USAGE_IMMUTABLE) && (img->cmn.num_slots == 1));
         SOKOL_ASSERT(!img->gl.ext_textures);   /* cannot provide external texture for depth images */
@@ -6957,11 +6961,21 @@ _SOKOL_PRIVATE sg_resource_state _sg_gl_create_pass(_sg_pass_t* pass, _sg_image_
 
     /* attach depth-stencil buffer to framebuffer */
     if (pass->gl.ds_att.image) {
-        const GLuint gl_render_buffer = pass->gl.ds_att.image->gl.depth_render_buffer;
-        SOKOL_ASSERT(gl_render_buffer);
-        glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, gl_render_buffer);
-        if (_sg_is_depth_stencil_format(pass->gl.ds_att.image->cmn.pixel_format)) {
-            glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_STENCIL_ATTACHMENT, GL_RENDERBUFFER, gl_render_buffer);
+        if (_sg.gl.ext_depth_read) {
+            const GLuint gl_depth_tex = pass->gl.ds_att.image->gl.tex[0];
+            SOKOL_ASSERT(gl_depth_tex);
+            glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_TEXTURE_2D, gl_depth_tex, 0);
+             if (_sg_is_depth_stencil_format(pass->gl.ds_att.image->cmn.pixel_format)) {
+                glFramebufferTexture2D(GL_FRAMEBUFFER, GL_STENCIL_ATTACHMENT, GL_TEXTURE_2D, gl_depth_tex, 0);
+            }
+        }
+        else {
+            const GLuint gl_render_buffer = pass->gl.ds_att.image->gl.depth_render_buffer;
+            SOKOL_ASSERT(gl_render_buffer);
+            glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, gl_render_buffer);
+            if (_sg_is_depth_stencil_format(pass->gl.ds_att.image->cmn.pixel_format)) {
+                glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_STENCIL_ATTACHMENT, GL_RENDERBUFFER, gl_render_buffer);
+            }
         }
     }
 
@@ -8585,15 +8599,27 @@ _SOKOL_PRIVATE sg_resource_state _sg_d3d11_create_image(_sg_image_t* img, const
             SOKOL_LOG("trying to create a D3D11 depth-texture with unsupported pixel format\n");
             return SG_RESOURCESTATE_FAILED;
         }
+        /* need special typeless formats, only support known depth formats */
+        SOKOL_ASSERT(img->cmn.pixel_format == SG_PIXELFORMAT_DEPTH || img->cmn.pixel_format == SG_PIXELFORMAT_DEPTH_STENCIL);
+        DXGI_FORMAT res_format = {};
+        DXGI_FORMAT srv_format = {};
+        if (img->cmn.pixel_format == SG_PIXELFORMAT_DEPTH) {
+            res_format = DXGI_FORMAT_R32_TYPELESS;
+            srv_format = DXGI_FORMAT_R32_FLOAT;
+        }
+        else if (img->cmn.pixel_format == SG_PIXELFORMAT_DEPTH_STENCIL) {
+            res_format = DXGI_FORMAT_R24G8_TYPELESS;
+            srv_format = DXGI_FORMAT_R24_UNORM_X8_TYPELESS;
+        }
         D3D11_TEXTURE2D_DESC d3d11_desc;
         memset(&d3d11_desc, 0, sizeof(d3d11_desc));
         d3d11_desc.Width = (UINT)img->cmn.width;
         d3d11_desc.Height = (UINT)img->cmn.height;
         d3d11_desc.MipLevels = 1;
         d3d11_desc.ArraySize = 1;
-        d3d11_desc.Format = img->d3d11.format;
+        d3d11_desc.Format = res_format;
         d3d11_desc.Usage = D3D11_USAGE_DEFAULT;
-        d3d11_desc.BindFlags = D3D11_BIND_DEPTH_STENCIL;
+        d3d11_desc.BindFlags = D3D11_BIND_DEPTH_STENCIL | D3D11_BIND_SHADER_RESOURCE;
         d3d11_desc.SampleDesc.Count = (UINT)img->cmn.sample_count;
         d3d11_desc.SampleDesc.Quality = (UINT) (msaa ? D3D11_STANDARD_MULTISAMPLE_PATTERN : 0);
         hr = _sg_d3d11_CreateTexture2D(_sg.d3d11.dev, &d3d11_desc, NULL, &img->d3d11.texds);
@@ -8601,6 +8627,14 @@ _SOKOL_PRIVATE sg_resource_state _sg_d3d11_create_image(_sg_image_t* img, const
             SOKOL_LOG("failed to create D3D11 texture 2D\n");
             return SG_RESOURCESTATE_FAILED;
         }
+
+        D3D11_SHADER_RESOURCE_VIEW_DESC d3d11_srv_desc;
+        memset(&d3d11_srv_desc, 0, sizeof(d3d11_srv_desc));
+        d3d11_srv_desc.Format = srv_format;
+        d3d11_srv_desc.ViewDimension = D3D11_SRV_DIMENSION_TEXTURE2D;
+        d3d11_srv_desc.Texture2D.MipLevels = 1;
+        hr = _sg_d3d11_CreateShaderResourceView(_sg.d3d11.dev, (ID3D11Resource*)img->d3d11.texds, &d3d11_srv_desc, &img->d3d11.srv);
+        SOKOL_ASSERT(SUCCEEDED(hr) && img->d3d11.srv);
     }
     else {
         /* create (or inject) color texture and shader-resource-view */
@@ -8789,38 +8823,36 @@ _SOKOL_PRIVATE sg_resource_state _sg_d3d11_create_image(_sg_image_t* img, const
                 return SG_RESOURCESTATE_FAILED;
             }
         }
+    }
 
-        /* sampler state object, note D3D11 implements an internal shared-pool for sampler objects */
-        D3D11_SAMPLER_DESC d3d11_smp_desc;
-        memset(&d3d11_smp_desc, 0, sizeof(d3d11_smp_desc));
-        d3d11_smp_desc.Filter = _sg_d3d11_filter(img->cmn.min_filter, img->cmn.mag_filter, img->cmn.max_anisotropy);
-        d3d11_smp_desc.AddressU = _sg_d3d11_address_mode(img->cmn.wrap_u);
-        d3d11_smp_desc.AddressV = _sg_d3d11_address_mode(img->cmn.wrap_v);
-        d3d11_smp_desc.AddressW = _sg_d3d11_address_mode(img->cmn.wrap_w);
-        switch (img->cmn.border_color) {
-            case SG_BORDERCOLOR_TRANSPARENT_BLACK:
-                /* all 0.0f */
-                break;
-            case SG_BORDERCOLOR_OPAQUE_WHITE:
-                for (int i = 0; i < 4; i++) {
-                    d3d11_smp_desc.BorderColor[i] = 1.0f;
-                }
-                break;
-            default:
-                /* opaque black */
-                d3d11_smp_desc.BorderColor[3] = 1.0f;
-                break;
-        }
-        d3d11_smp_desc.MaxAnisotropy = img->cmn.max_anisotropy;
-        d3d11_smp_desc.ComparisonFunc = D3D11_COMPARISON_NEVER;
-        d3d11_smp_desc.MinLOD = desc->min_lod;
-        d3d11_smp_desc.MaxLOD = desc->max_lod;
-        hr = _sg_d3d11_CreateSamplerState(_sg.d3d11.dev, &d3d11_smp_desc, &img->d3d11.smp);
-        if (!(SUCCEEDED(hr) && img->d3d11.smp)) {
-            SOKOL_LOG("failed to create D3D11 sampler state\n");
-            return SG_RESOURCESTATE_FAILED;
-        }
+    /* sampler state object, note D3D11 implements an internal shared-pool for sampler objects */
+    D3D11_SAMPLER_DESC d3d11_smp_desc;
+    memset(&d3d11_smp_desc, 0, sizeof(d3d11_smp_desc));
+    d3d11_smp_desc.Filter = _sg_d3d11_filter(img->cmn.min_filter, img->cmn.mag_filter, img->cmn.max_anisotropy);
+    d3d11_smp_desc.AddressU = _sg_d3d11_address_mode(img->cmn.wrap_u);
+    d3d11_smp_desc.AddressV = _sg_d3d11_address_mode(img->cmn.wrap_v);
+    d3d11_smp_desc.AddressW = _sg_d3d11_address_mode(img->cmn.wrap_w);
+    switch (img->cmn.border_color) {
+        case SG_BORDERCOLOR_TRANSPARENT_BLACK:
+            /* all 0.0f */
+            break;
+        case SG_BORDERCOLOR_OPAQUE_WHITE:
+            for (int i = 0; i < 4; i++) {
+                d3d11_smp_desc.BorderColor[i] = 1.0f;
+            }
+            break;
+        default:
+            /* opaque black */
+            d3d11_smp_desc.BorderColor[3] = 1.0f;
+            break;
     }
+    d3d11_smp_desc.MaxAnisotropy = img->cmn.max_anisotropy;
+    d3d11_smp_desc.ComparisonFunc = D3D11_COMPARISON_NEVER;
+    d3d11_smp_desc.MinLOD = desc->min_lod;
+    d3d11_smp_desc.MaxLOD = desc->max_lod;
+    hr = _sg_d3d11_CreateSamplerState(_sg.d3d11.dev, &d3d11_smp_desc, &img->d3d11.smp);
+    SOKOL_ASSERT(SUCCEEDED(hr) && img->d3d11.smp);
+
     return SG_RESOURCESTATE_VALID;
 }
 
@@ -10626,10 +10658,11 @@ _SOKOL_PRIVATE sg_resource_state _sg_mtl_create_image(_sg_image_t* img, const sg
             id<MTLTexture> tex = [_sg.mtl.device newTextureWithDescriptor:mtl_desc];
             img->mtl.msaa_tex = _sg_mtl_add_resource(tex);
         }
-
-        /* create (possibly shared) sampler state */
-        img->mtl.sampler_state = _sg_mtl_create_sampler(_sg.mtl.device, desc);
     }
+
+    /* create (possibly shared) sampler state */
+    img->mtl.sampler_state = _sg_mtl_create_sampler(_sg.mtl.device, desc);
+
     _SG_OBJC_RELEASE(mtl_desc);
     return SG_RESOURCESTATE_VALID;
 }
@@ -11214,8 +11247,14 @@ _SOKOL_PRIVATE void _sg_mtl_apply_bindings(
         if ((_sg.mtl.state_cache.cur_fs_images[slot] != img) || (_sg.mtl.state_cache.cur_fs_image_ids[slot].id != img->slot.id)) {
             _sg.mtl.state_cache.cur_fs_images[slot] = img;
             _sg.mtl.state_cache.cur_fs_image_ids[slot].id = img->slot.id;
-            SOKOL_ASSERT(img->mtl.tex[img->cmn.active_slot] != _SG_MTL_INVALID_SLOT_INDEX);
-            [_sg.mtl.cmd_encoder setFragmentTexture:_sg_mtl_id(img->mtl.tex[img->cmn.active_slot]) atIndex:slot];
+            SOKOL_ASSERT(img->mtl.tex[img->cmn.active_slot] != _SG_MTL_INVALID_SLOT_INDEX ||
+                img->mtl.depth_tex != _SG_MTL_INVALID_SLOT_INDEX);
+            if (img->mtl.depth_tex) {
+                [_sg.mtl.cmd_encoder setFragmentTexture:_sg_mtl_id(img->mtl.depth_tex) atIndex:slot];
+            }
+            else {
+                [_sg.mtl.cmd_encoder setFragmentTexture:_sg_mtl_id(img->mtl.tex[img->cmn.active_slot]) atIndex:slot];
+            }
             SOKOL_ASSERT(img->mtl.sampler_state != _SG_MTL_INVALID_SLOT_INDEX);
             [_sg.mtl.cmd_encoder setFragmentSamplerState:_sg_mtl_id(img->mtl.sampler_state) atIndex:slot];
         }
-- 
2.35.0

